"""
Views для отображения заявок на пополнение и вывод
"""

from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.core.paginator import Paginator
from django.db.models import Q
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from datetime import timedelta
import json
import logging
import sqlite3
from django.conf import settings

from .models import BankNotification, AutoDepositRequest, PlayerBalance
from .auto_deposit_models import BankNotification as BankNotificationModel, AutoDepositRequest
from .bot_models import BotDepositRequestRaw, BotWithdrawRequestRaw

logger = logging.getLogger(__name__)

def deposits_list(request):
    """
    Главная страница с заявками: читаем из единой таблицы requests
    """
    try:
        conn = sqlite3.connect(str(settings.BOT_DATABASE_PATH))
        cursor = conn.cursor()

        # Если таблицы requests нет
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='requests'")
        if cursor.fetchone() is None:
            return render(request, 'bot_control/error.html', {'error': 'Таблица requests не найдена. Выполните миграцию.'})

        cursor.execute('''
            SELECT id, user_id, COALESCE(username,''), COALESCE(first_name,''),
                   COALESCE(bookmaker,''), COALESCE(amount,0), COALESCE(status,'pending'),
                   COALESCE(created_at,''), COALESCE(request_type,'deposit'), COALESCE(photo_file_url,'')
            FROM requests
            ORDER BY datetime(COALESCE(created_at,'1970-01-01')) DESC
            LIMIT 200
        ''')
        all_requests = []
        for (rid, user_id, username, first_name, bookmaker, amount, status, created_at, req_type, photo_url) in cursor.fetchall():
            all_requests.append({
                'id': rid,
                'user_id': user_id,
                'username': username or first_name or f'user_{user_id}',
                'first_name': first_name,
                'bookmaker': bookmaker,
                'amount': amount,
                'status': status,
                'created_at': created_at,
                'type': 'deposit' if req_type == 'deposit' else 'withdrawal',
                'photo_url': photo_url,
            })

        conn.close()

        # Фильтр: показываем только ожидающие/в обработке
        pending_statuses = {'pending', 'processing'}
        all_requests = [r for r in all_requests if (r.get('status') or 'pending') in pending_statuses]

        all_requests.sort(key=lambda x: x['created_at'] or '', reverse=True)
        paginator = Paginator(all_requests, 20)
        page_obj = paginator.get_page(1)

        context = {
            'page_obj': page_obj,
            'total_requests': len(all_requests),
        }
        return render(request, 'bot_control/deposits_list.html', context)

    except Exception as e:
        return render(request, 'bot_control/error.html', {'error': str(e)})

def transaction_detail(request, trans_id):
    """Детальная информация из таблицы requests"""
    try:
        conn = sqlite3.connect(str(settings.BOT_DATABASE_PATH))
        cursor = conn.cursor()

        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='requests'")
        if cursor.fetchone() is None:
            return render(request, 'bot_control/error.html', {'error': 'Таблица requests не найдена. Выполните миграцию.'})

        cursor.execute('''
            SELECT id, user_id, COALESCE(username,''), COALESCE(first_name,''), COALESCE(last_name,''),
                   COALESCE(bookmaker,''), COALESCE(account_id,''), COALESCE(amount,0),
                   COALESCE(status,'pending'), COALESCE(created_at,''), COALESCE(request_type,'deposit'),
                   COALESCE(photo_file_url,'')
            FROM requests
            WHERE id = ?
        ''', (trans_id,))
        row = cursor.fetchone()
        conn.close()
        if not row:
            return render(request, 'bot_control/error.html', {'error': 'Заявка не найдена'})

        rid, user_id, username, first_name, last_name, bookmaker, account_id, amount, status, created_at, req_type, photo_url_db = row
        context = {
            'id': rid,
            'user_id': user_id,
            'username': username or f"{first_name} {last_name}".strip() or f'user_{user_id}',
            'bookmaker': bookmaker,
            'type': 'deposit' if req_type == 'deposit' else 'withdrawal',
            'amount': float(amount) if amount is not None else 0.0,
            'status': status,
            'created_at': created_at,
            'source': 'requests',
            'photo_url': photo_url_db or '',
        }
        return render(request, 'bot_control/transaction_detail.html', context)

    except Exception as e:
        return render(request, 'bot_control/error.html', {'error': str(e)})

def deposit_detail(request, deposit_id):
    """
    Детальная информация о заявке на пополнение
    """
    try:
        deposit = get_object_or_404(AutoDepositRequest, id=deposit_id)
        
        # Получаем связанные уведомления (пока заглушка)
        notifications = []
        
        # Получаем баланс игрока (пока заглушка)
        player_balance = None
        
        # Получаем историю операций игрока (пока заглушка)
        user_history = []
        
        context = {
            'deposit': deposit,
            'notifications': notifications,
            'player_balance': player_balance,
            'user_history': user_history,
        }
        
        return render(request, 'bot_control/mobile_deposit_detail.html', context)
        
    except Exception as e:
        return render(request, 'bot_control/error.html', {'error': str(e)})

def withdrawals_list(request):
    """
    Список заявок на вывод
    """
    try:
        # Получаем фильтры
        status_filter = request.GET.get('status', 'all')
        search_query = request.GET.get('search', '')
        page_number = request.GET.get('page', 1)
        
        # Подключаемся к базе данных бота
        conn = sqlite3.connect(str(settings.BOT_DATABASE_PATH))
        conn.row_factory = sqlite3.Row  # Для доступа к полям по имени
        cursor = conn.cursor()
        
        # Базовый запрос для выводов
        query = '''
            SELECT wr.*, 
                   u.username, 
                   u.first_name, 
                   u.phone_number,
                   u.balance as user_balance
            FROM withdrawal_requests wr
            LEFT JOIN users u ON wr.user_id = u.user_id
            WHERE 1=1
        '''
        
        params = []
        
        # Фильтрация по статусу
        if status_filter != 'all':
            query += ' AND wr.status = ?'
            params.append(status_filter)
        
        # Поиск
        if search_query:
            query += ' AND (wr.user_id LIKE ? OR wr.amount LIKE ? OR wr.wallet_details LIKE ? OR u.username LIKE ? OR u.first_name LIKE ? OR u.phone_number LIKE ?)'
            search_param = f'%{search_query}%'
            params.extend([search_param] * 6)
        
        # Сортировка
        query += ' ORDER BY wr.created_at DESC'
        
        # Выполняем запрос для получения данных
        cursor.execute(query, params)
        all_withdrawals = cursor.fetchall()
        
        # Получаем статистику
        cursor.execute('''
            SELECT 
                COUNT(*) as total,
                SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected
            FROM withdrawal_requests
        ''')
        
        stats_row = cursor.fetchone()
        stats = {
            'total': stats_row['total'] or 0,
            'pending': stats_row['pending'] or 0,
            'completed': stats_row['completed'] or 0,
            'rejected': stats_row['rejected'] or 0,
        }
        
        # Пагинация
        paginator = Paginator(all_withdrawals, 20)
        page_obj = paginator.get_page(page_number)
        
        # Преобразуем строки в словари для удобства работы в шаблоне
        withdrawals_list = []
        for row in page_obj.object_list:
            withdrawals_list.append(dict(row))
        
        context = {
            'page_obj': page_obj,
            'withdrawals': withdrawals_list,
            'stats': stats,
            'status_filter': status_filter,
            'search_query': search_query,
        }
        
        conn.close()
        return render(request, 'bot_control/withdrawals_list.html', context)
        
    except Exception as e:
        logger.error(f"Error in withdrawals_list: {str(e)}", exc_info=True)
        return render(request, 'bot_control/error.html', {'error': str(e)})

def dashboard(request):
    """
    Главная панель управления
{{ ... }}
    try:
        # Статистика за сегодня
        today = timezone.now().date()
        today_deposits = AutoDepositRequest.objects.filter(
            request_type='deposit',
            created_at__date=today
        )
        today_withdrawals = AutoDepositRequest.objects.filter(
            request_type='withdraw',
            created_at__date=today
        )
        
        # Статистика за последние 7 дней
        week_ago = timezone.now() - timedelta(days=7)
        week_deposits = AutoDepositRequest.objects.filter(
            request_type='deposit',
            created_at__gte=week_ago
        )
        week_withdrawals = AutoDepositRequest.objects.filter(
            request_type='withdraw',
            created_at__gte=week_ago
        )
        
        # Последние заявки
        recent_deposits = AutoDepositRequest.objects.filter(
            request_type='deposit'
        ).order_by('-created_at')[:10]
        
        recent_withdrawals = AutoDepositRequest.objects.filter(
            request_type='withdraw'
        ).order_by('-created_at')[:10]
        
        # Статистика по статусам
        deposit_stats = {
            'pending': AutoDepositRequest.objects.filter(
                request_type='deposit',
                status='pending'
            ).count(),
            'completed': AutoDepositRequest.objects.filter(
                request_type='deposit',
                status='completed'
            ).count(),
            'auto_completed': AutoDepositRequest.objects.filter(
                request_type='deposit',
                status='auto_completed'
            ).count(),
            'rejected': AutoDepositRequest.objects.filter(
                request_type='deposit',
                status='rejected'
            ).count(),
        }
        
        withdrawal_stats = {
            'pending': AutoDepositRequest.objects.filter(
                request_type='withdraw',
                status='pending'
            ).count(),
            'completed': AutoDepositRequest.objects.filter(
                request_type='withdraw',
                status='completed'
            ).count(),
            'rejected': AutoDepositRequest.objects.filter(
                request_type='withdraw',
                status='rejected'
            ).count(),
        }
        
        context = {
            'today_deposits': today_deposits.count(),
            'today_withdrawals': today_withdrawals.count(),
            'week_deposits': week_deposits.count(),
            'week_withdrawals': week_withdrawals.count(),
            'recent_deposits': recent_deposits,
            'recent_withdrawals': recent_withdrawals,
            'deposit_stats': deposit_stats,
            'withdrawal_stats': withdrawal_stats,
        }
        
        return render(request, 'bot_control/dashboard.html', context)
        
    except Exception as e:
        return render(request, 'bot_control/error.html', {'error': str(e)})

def api_deposit_status(request, deposit_id):
    """
    """API для обновления статуса заявки"""
    """
    try:
        if request.method == 'POST':
            data = json.loads(request.body)
            new_status = data.get('status')
            admin_comment = data.get('comment', '')
            
            deposit = get_object_or_404(AutoDepositRequest, id=deposit_id)
            deposit.status = new_status
            deposit.admin_comment = admin_comment
            deposit.updated_at = timezone.now()
            deposit.save()
            
            return JsonResponse({
                'success': True,
                'message': f'Статус заявки {deposit_id} обновлен на {new_status}'
            })
        else:
            return JsonResponse({'error': 'Method not allowed'}, status=405)
            
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@require_http_methods(["POST"])
def auto_deposit_api(request):
    """
    API for processing automatic deposits
    """
    try:
        data = json.loads(request.body)
        
        request_id = data.get('request_id')
        user_id = data.get('user_id')
        amount = data.get('amount')
        bookmaker = data.get('bookmaker')
        transaction_date = data.get('transaction_date')
        source = data.get('source', 'email_parser')
        
        logger.info(f"Получено автоматическое пополнение: {request_id}, {amount} KGS, {bookmaker}")
        
        # Обновляем заявку в Django базе
        try:
            deposit_request = AutoDepositRequest.objects.get(id=request_id)
            deposit_request.status = 'completed'
            deposit_request.completed_at = timezone.now()
            deposit_request.auto_deposit_data = json.dumps({
                'source': source,
                'transaction_date': transaction_date,
                'amount': amount
            })
            deposit_request.save()
            
            logger.info(f"Заявка {request_id} обновлена в Django базе")
            
        except AutoDepositRequest.DoesNotExist:
            logger.warning(f"Заявка {request_id} не найдена в Django базе")
        
        # Создаем уведомление о банке
        BankNotificationModel.objects.create(
            amount=amount,
            bank='demirbank',
            notification_text=f"Автоматическое пополнение на {amount} KGS от {source}",
            raw_data=json.dumps(data),
            is_processed=True,
            processed_at=timezone.now()
        )
        
        # Здесь можно добавить логику отправки уведомления в Telegram группу
        # и обновления баланса игрока
        
        return JsonResponse({
            'success': True,
            'message': 'Автоматическое пополнение обработано'
        })
        
    except Exception as e:
        logger.error(f"Ошибка обработки автоматического пополнения: {e}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createApiResponse } from '@/lib/api-helpers'
import { 
  protectAPI, 
  rateLimit, 
  sanitizeInput, 
  containsSQLInjection,
  getClientIP 
} from '@/lib/security'

// –ü—É–±–ª–∏—á–Ω—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ —Å–∞–π—Ç–∞)
export async function GET(request: NextRequest) {
  try {
    // üõ°Ô∏è –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø –ó–ê–©–ò–¢–ê
    const protectionResult = protectAPI(request)
    if (protectionResult) return protectionResult

    // Rate limiting (—Å—Ç—Ä–æ–≥–∏–π –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–≥–æ endpoint)
    const rateLimitResult = rateLimit({ 
      maxRequests: 20, 
      windowMs: 60 * 1000,
      keyGenerator: (req) => `check_user:${getClientIP(req)}`
    })(request)
    if (rateLimitResult) return rateLimitResult

    const { searchParams } = new URL(request.url)
    let userId = searchParams.get('user_id')

    // üõ°Ô∏è –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –æ—á–∏—Å—Ç–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (!userId) {
      return NextResponse.json(
        createApiResponse(null, 'User ID is required'),
        { status: 400 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ SQL –∏–Ω—ä–µ–∫—Ü–∏–∏
    if (containsSQLInjection(userId)) {
      console.warn(`üö´ SQL injection attempt from ${getClientIP(request)}: ${userId}`)
      return NextResponse.json(
        createApiResponse(null, 'Invalid input'),
        { status: 400 }
      )
    }

    // –û—á–∏—Å—Ç–∫–∞ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è
    userId = sanitizeInput(userId) as string

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º)
    if (!/^\d+$/.test(userId)) {
      return NextResponse.json(
        createApiResponse(null, 'Invalid user ID format'),
        { status: 400 }
      )
    }

    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã
    if (userId.length > 20) {
      return NextResponse.json(
        createApiResponse(null, 'User ID too long'),
        { status: 400 }
      )
    }

    if (!userId) {
      return NextResponse.json(
        createApiResponse(null, 'User ID is required'),
        { status: 400 }
      )
    }

    let userIdBigInt: bigint
    try {
      userIdBigInt = BigInt(userId)
    } catch (e) {
      return NextResponse.json(
        createApiResponse(null, 'Invalid user ID'),
        { status: 400 }
      )
    }

    const user = await prisma.botUser.findUnique({
      where: { userId: userIdBigInt },
      select: {
        isActive: true,
      },
    })

    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å—á–∏—Ç–∞–µ–º –µ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã–º (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
    const isActive = user?.isActive !== false

    return NextResponse.json(
      createApiResponse({
        isActive,
        isBlocked: !isActive,
      })
    )
  } catch (error: any) {
    return NextResponse.json(
      createApiResponse(null, error.message || 'Failed to check user status'),
      { status: 500 }
    )
  }
}

export const dynamic = 'force-dynamic'

